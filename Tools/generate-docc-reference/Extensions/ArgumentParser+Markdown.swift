//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Argument Parser open source project
//
// Copyright (c) 2021 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

import ArgumentParser
import ArgumentParserToolInfo

extension CommandInfoV0 {
  var doccReferenceFileName: String {
    doccReferenceTitle + ".md"
  }

  var doccReferenceDocumentTitle: String {
    let parts = (superCommands ?? []) + [commandName]
    return parts.joined(separator: ".").uppercased()
  }

  var doccReferenceTitle: String {
    let parts = (superCommands ?? []) + [commandName]
    return parts.joined(separator: ".")
  }

  var doccReferenceName: String {
    let parts = (superCommands ?? []) + [commandName]
    return parts.joined(separator: " ")
  }
}

extension CommandInfoV0 {
  func toMarkdown(_ path: [String]) -> String {
    var result =
      String(repeating: "#", count: path.count + 1)
      + " \(self.doccReferenceTitle)\n\n"

    if path.count == 0 {
      result += "<!-- Generated by swift-argument-parser -->\n\n"
    }

    if let abstract = self.abstract {
      result += "\(abstract)\n\n"
    }

    if let args = self.arguments, args.count != 0 {
      result += "```\n"
      result +=
        (path + [self.commandName]).joined(separator: " ") + " " + self.usage()
      result += "\n```\n\n"
    }

    if let discussion = self.discussion {
      result += "\(discussion)\n\n"
    }

    if let args = self.arguments {
      // Group arguments by sectionTitle
      // This is done to organize the arguments into categories (e.g., optionals, flags)
      let groupedArgs = Dictionary(
        grouping: args.filter {
          $0.shouldDisplay
        }
      ) { self.assignSectionTitle(to: $0) }

      // Iterate through the grouped arguments, sorted by section title
      // Sorting ensures that the sections appear in a clear, predictable order in the final documentation.
      // The sections are listed alphabetically based on their title, enhancing readability.
      for (section, arguments) in groupedArgs.sorted(by: { $0.key < $1.key }) {
        // Add section title as a Markdown header to the result
        // Adding section titles as Markdown headers helps separate sections in the documentation,
        // making it easier for users to navigate and understand the structure of the arguments.
        result += "### \(section)\n\n"

        // Iterate through each argument in the section
        // Iterating through each argument allows us to add details for each argument under its respective section.
        for arg in arguments {
          // Add the argument identity in bold Markdown format
          // The argument identity is emphasized in bold to make it stand out in the documentation.
          result += "**`\(arg.identity())`**\n\n"

          // If the argument has an abstract, add it in italic Markdown format
          // Including the abstract provides a brief description of the argument's purpose.
          // The italic formatting helps to distinguish the abstract from other parts of the documentation.
          if let abstract = arg.abstract {
            result += "*\(abstract)*\n\n"
          }

          // If the argument has a discussion, add it directly
          // If a discussion is available, it is added to provide further explanation on how the argument works.
          // This additional context is helpful for users to understand the full usage of the argument.
          if let discussion = arg.discussion {
            result += discussion + "\n\n"
          }

          // Add an empty line for separation between arguments
          // The empty line improves the visual structure of the documentation,
          // making it easier to read and separating each argument for clarity.
          result += "\n"
        }
      }
    }

    for subcommand in self.subcommands ?? [] {
      result += subcommand.toMarkdown(path + [self.commandName]) + "\n\n"
    }

    // Trim any unnecessary trailing newline that could have been added inadvertently
    // By trimming, we prevent extra lines at the end of the generated document
    // which is important for snapshot comparison.
    result = result.trimmingCharacters(in: .newlines)

    return result
  }

  public func usage() -> String {
    guard let args = self.arguments else {
      return ""
    }

    return args.map { $0.usage() }.joined(separator: " ")
  }

  // Assign a default section title based on the arguments types
  func assignSectionTitle(to argument: ArgumentInfoV0) -> String {
    if let sectionTitle = argument.sectionTitle {
      return sectionTitle
    } else {
      switch argument.kind {
      case .positional:
        return "Arguments"
      case .option:
        return "Options"
      case .flag:
        return "Flags"
      }
    }
  }
}


extension ArgumentInfoV0 {
  public func usage() -> String {
    guard self.shouldDisplay else {
      return ""
    }

    let names: [String]

    if let myNames = self.names {
      names = myNames.filter { $0.kind == .long }.map(\.name)
    } else if let preferred = self.preferredName {
      names = [preferred.name]
    } else if let value = self.valueName {
      names = [value]
    } else {
      return ""
    }

    // TODO: default values, short, etc.

    var inner: String
    switch self.kind {
    case .positional:
      inner = "<\(names.joined(separator: "|"))>"
    case .option:
      inner = "--\(names.joined(separator: "|"))=<\(self.valueName ?? "")>"
    case .flag:
      inner = "--\(names.joined(separator: "|"))"
    }

    if self.isRepeating {
      inner += "..."
    }

    if self.isOptional {
      return "[\(inner)]"
    }

    return inner
  }

  public func identity() -> String {
    let names: [String]
    if let myNames = self.names {
      names = myNames.filter { $0.kind == .long }.map(\.name)
    } else if let preferred = self.preferredName {
      names = [preferred.name]
    } else if let value = self.valueName {
      names = [value]
    } else {
      return ""
    }

    // TODO: default values, values, short, etc.

    let inner: String
    switch self.kind {
    case .positional:
      inner = "\(names.joined(separator: "|"))"
    case .option:
      inner = "--\(names.joined(separator: "|"))=\\<\(self.valueName ?? "")\\>"
    case .flag:
      inner = "--\(names.joined(separator: "|"))"
    }
    return inner
  }
}
